<!DOCTYPE html>
<html lang=zh-CN>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="傅大帅的个人博客">
  <meta name="keywords" content="火柴">
  
    <link rel="icon" href="/images/favicon.png">
  
    
  <title>单例模式（Singleton Pattern) | 叮咚火柴的博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class="logo" href="/">
      <span>叮咚火柴的博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id="post">
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>单例模式（Singleton Pattern)</h1>
          <div class="post-meta">
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年01月18日</time>
            
            
              | 
                  <i class="fa fa-tags" aria-hidden="true"></i>
                
               
  <a href="/tags/#学习笔记" class="tag">学习笔记</a>

  <a href="/tags/#设计模式" class="tag">设计模式</a>


            
          </div>
          <h1 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h1><p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br><br>单例模式有以下特点：<br></p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong><br><br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><br><strong>主要解决：</strong><br><br>一个全局使用的类频繁地创建与销毁。<br><br><strong>何时使用：</strong><br><br>当您想控制实例数目，节省系统资源的时候。<br><br><strong>如何解决：</strong><br><br>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><br><strong>关键代码：</strong><br><br>构造函数是私有的。<br><br><strong>应用实例：</strong><br></p>
<ul>
<li>Windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理，不能两台打印机打印同一个文件。</li>
</ul>
<p><strong>优点：</strong> <br></p>
<ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong><br></p>
<ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ul>
<p><strong>使用场景：</strong><br></p>
<ul>
<li>要求生产唯一序列号。</li>
<li>WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 </li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<p><strong>注意事项：</strong><br><br>getInstance()方法中需要使用同步锁synchronized(Singleton.class)防止多线程同时进入造成instance被多次实例化。<br></p>
<p><strong>静态对象：</strong></p>
<ul>
<li>静态对象的数据在全局是唯一的，一改都改。如果你想要处理的东西是整个程序中唯一的，弄成静态是个好方法。 非静态的东西你修改以后只是修改了他自己的数据，但是不会影响其他同类对象的数据。 </li>
<li>引用方便。直接用<strong>类名.静态方法名</strong>或者<strong>类名.静态变量名</strong>就可引用并且直接可以修改其属性值，不用get和set方法。</li>
<li>保持数据的唯一性。此数据全局都是唯一的，修改他的任何一处地方，在程序所有使用到的地方都将会体现到这些数据的修改。有效减少多余的浪费。</li>
<li>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”。对于变量，表示一旦给值就不可修改；对于方法，表示不可覆盖。</li>
</ul>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img src="/images/singleton/1.png" alt=""><br></p>
<h1 id="常见的实现方式"><a href="#常见的实现方式" class="headerlink" title="常见的实现方式"></a>常见的实现方式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><strong>优点：</strong><br></p>
<ul>
<li>没有加锁，执行效率会提高。</li>
<li>在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</li>
</ul>
<p><strong>缺点：</strong><br></p>
<ul>
<li>类加载时就初始化，浪费内存,容易产生垃圾对象,jvm垃圾收集器是不会回收单例对象（静态）。——垃圾回收属个人观点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.match.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式：</span><br><span class="line"> * 保证一个类只能产生一个对象</span><br><span class="line"> * 测试饿汉式单例模式(线程安全，调用效率高，但是不可以延迟加载)</span><br><span class="line"> * @author Match</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingletonDemo1</span><br><span class="line">&#123;</span><br><span class="line">	//类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！</span><br><span class="line">	private static SingletonDemo1 instance = new SingletonDemo1();</span><br><span class="line">	private SingletonDemo1()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	//方法没有同步锁，调用效率高！</span><br><span class="line">	public static SingletonDemo1 getInstance()</span><br><span class="line">	&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>此处只介绍线程安全的懒汉式。线程不安全的懒汉式只是没加同步锁(synchronized)，严格意义上它并不算单例模式。<br><br><strong>优点：</strong><br></p>
<ul>
<li>具备延时加载（lazy loading）第一次调用才初始化，避免内存浪费，能够在多线程中很好的工作。</li>
</ul>
<p><strong>缺点：</strong><br></p>
<ul>
<li>必须加锁 synchronized 才能保证单例，但加锁会影响效率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.match.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 单例模式：</span><br><span class="line"> * 保证一个类只能产生一个对象</span><br><span class="line"> * 测试懒汉式单例模式（线程安全，调用效率不高，但是可以延迟加载）</span><br><span class="line"> * @author Match</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingletonDemo2</span><br><span class="line">&#123;</span><br><span class="line">	//类初始化时，不初始化这个对象（延时加载，正真用的时候再创建）。</span><br><span class="line">	private static SingletonDemo2 instance;</span><br><span class="line">	private SingletonDemo2()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	//方法同步，调用效率低！</span><br><span class="line">	public static synchronized SingletonDemo2 getInstance()</span><br><span class="line">	&#123;</span><br><span class="line">		if(instance==null)</span><br><span class="line">			instance = new SingletonDemo2(); </span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h2><p>注：要求JDK1.5起。<br><br><strong>优点：</strong><br></p>
<ul>
<li>具备延时加载（lazy loading）第一次调用才初始化，避免内存浪费，采用双锁机制，安全且在多线程情况下能保持高性能。</li>
</ul>
<p><strong>缺点：</strong><br></p>
<ul>
<li>实现起来比较复杂。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.match.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 双重检测锁实现单例模式</span><br><span class="line"> * @author Match</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingletonDemo3</span><br><span class="line">&#123;</span><br><span class="line">	private static SingletonDemo3 instance = null;</span><br><span class="line">	</span><br><span class="line">	private SingletonDemo3()</span><br><span class="line">	&#123;	</span><br><span class="line">	&#125;</span><br><span class="line">	public static SingletonDemo3 getInstance() </span><br><span class="line">	&#123;</span><br><span class="line">		if(instance==null)</span><br><span class="line">		&#123;</span><br><span class="line">			SingletonDemo3 sc;</span><br><span class="line">			synchronized(SingletonDemo3.class)</span><br><span class="line">			&#123;</span><br><span class="line">				sc = instance;</span><br><span class="line">				if(sc==null)</span><br><span class="line">				&#123;</span><br><span class="line">					synchronized(SingletonDemo3.class)</span><br><span class="line">					&#123;</span><br><span class="line">						if(sc==null)</span><br><span class="line">						&#123;</span><br><span class="line">							sc = new SingletonDemo3();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					instance = sc;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="登记式-静态内部类——Initialization-on-Demand-Holder-IoDH-技术"><a href="#登记式-静态内部类——Initialization-on-Demand-Holder-IoDH-技术" class="headerlink" title="登记式/静态内部类——Initialization on Demand Holder (IoDH)技术"></a>登记式/静态内部类——Initialization on Demand Holder (IoDH)技术</h2><p><strong>描述：</strong><br><br>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br></p>
<p>这种方式同样利用了classloder机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是：饿汉式只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading 效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化instance。想象一下，如果实例化instance很消耗资源，所以想让它延迟加载，另外一方面，又不希望在Singleton类加载时就实例化，因为不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance 显然是不合适的。这个时候，这种方式相比饿汉式就显得很合理。<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.match.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 测试静态内部类实现单例模式</span><br><span class="line"> * 这种方式：线程安全，调用效率高，并且实现了延时加载！</span><br><span class="line"> * @author Match</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingletonDemo4</span><br><span class="line">&#123;</span><br><span class="line">	private SingletonDemo4()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">	private static class SingletonClassInstance</span><br><span class="line">	&#123;</span><br><span class="line">		private static final SingletonDemo4 instance = new SingletonDemo4();</span><br><span class="line">	&#125;</span><br><span class="line">	//方法没有同步，调用效率高。</span><br><span class="line">	public static SingletonDemo4 getInstance()</span><br><span class="line">	&#123;</span><br><span class="line">		return SingletonClassInstance.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>注：要求JDK1.5起。<br><br><strong>优点：</strong><br></p>
<ul>
<li>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化,不能通过reflection attack来调用私有构造方法,支持多线程。</li>
</ul>
<p><strong>缺点：</strong><br></p>
<ul>
<li>不具备延时加载（lazy loading）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.match.singleton;</span><br><span class="line">/**</span><br><span class="line"> * 测试枚举式单例模式（没有延时加载）</span><br><span class="line"> * @author Match</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public enum SingletonDemo5</span><br><span class="line">&#123;</span><br><span class="line">	//这个枚举元素，本身就是单例对象！</span><br><span class="line">	INSTANCE;</span><br><span class="line">	//添加自己需要的操作！</span><br><span class="line">	public void singletonOperation()</span><br><span class="line">	&#123;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如何防止反射和反序列化漏洞"><a href="#如何防止反射和反序列化漏洞" class="headerlink" title="如何防止反射和反序列化漏洞"></a>如何防止反射和反序列化漏洞</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.match.singleton;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectStreamException;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 单例模式：</span><br><span class="line"> * 保证一个类只能产生一个对象</span><br><span class="line"> * 测试懒汉式单例模式（线程安全，调用效率不高，但是可以延迟加载），如何防止反射和反序列化漏洞。</span><br><span class="line"> * @author Match</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SingletonDemo6 implements Serializable</span><br><span class="line">&#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line">	//类初始化时，不初始化这个对象（延时加载，正真用的时候再创建）。</span><br><span class="line">	private static SingletonDemo6 instance;</span><br><span class="line">	private SingletonDemo6()//私有化构造器</span><br><span class="line">	&#123;</span><br><span class="line">		//防止反射</span><br><span class="line">		if(instance!=null)</span><br><span class="line">		&#123;</span><br><span class="line">			throw new RuntimeException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//方法同步，调用效率低！</span><br><span class="line">	public static synchronized SingletonDemo6 getInstance()</span><br><span class="line">	&#123;</span><br><span class="line">		if(instance==null)</span><br><span class="line">			instance = new SingletonDemo6(); </span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">	//反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新对象</span><br><span class="line">	private Object readResolve() throws ObjectStreamException</span><br><span class="line">	&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </section>
    </article>
    
        <!-- disqus 评论框 start -->
        <div class="comment">
            <div id="disqus_thread" class="disqus-thread">
              <i>加载评论框需要翻墙</i>
            </div>
        </div>
        <!-- disqus 评论框 end -->
    
    
        <!-- livere 评论框 start -->
        <div class="comment">
            <div id="lv-container" data-id="city" data-uid="your_livere_uid"></div>
        </div>
        <!-- livere 评论框 end -->
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是单例模式？"><span class="toc-number">1.</span> <span class="toc-text">什么是单例模式？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类图"><span class="toc-number">2.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见的实现方式"><span class="toc-number">3.</span> <span class="toc-text">常见的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#饿汉式"><span class="toc-number">3.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#懒汉式"><span class="toc-number">3.2.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双检锁-双重校验锁（DCL，即-double-checked-locking）"><span class="toc-number">3.3.</span> <span class="toc-text">双检锁/双重校验锁（DCL，即 double-checked locking）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#登记式-静态内部类——Initialization-on-Demand-Holder-IoDH-技术"><span class="toc-number">3.4.</span> <span class="toc-text">登记式/静态内部类——Initialization on Demand Holder (IoDH)技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举"><span class="toc-number">3.5.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何防止反射和反序列化漏洞"><span class="toc-number">4.</span> <span class="toc-text">如何防止反射和反序列化漏洞</span></a></li></ol>
        </div>
    </div>
    
  </aside>
</main>

<!-- disqus 公共JS代码 -->
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = "dingdongmatch";
  var disqus_identifier = "https://dingdongmatch.github.io/2018/01/18/单例模式（Singleton Pattern）/";
  var disqus_url = "https://dingdongmatch.github.io/2018/01/18/单例模式（Singleton Pattern）/";

  isAgent(getDisqus)

  // determine user agent in China
  function isAgent(cb) {
    var url = '//graph.facebook.com/feed?callback=h';
    var xhr = new XMLHttpRequest();
    var called = false;
    xhr.open('GET', url);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
      called = true;
      cb(true);
      }
    };
    xhr.send();
    // timeout 1s, this facebook API is very fast.
    setTimeout(function() {
      if (!called) {
      xhr.abort();
      cb(false)
      }
    }, 1000);
  }

  function getDisqus(isAgent) {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; 
    dsq.async = true
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq)
  }
</script>
<!-- disqus 公共JS代码 end -->


<script type="text/javascript">
  (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];

      if (typeof LivereTower === 'function') { return; }

      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;

      e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>


  <footer>
  <div class="copyright">
    <div>
      &copy; 2019 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
